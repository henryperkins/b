from sqlalchemy.orm import Session
from typing import List, Optional
from ..models.conversation import Folder, Tag
from ..schemas.folder import FolderCreate, FolderUpdate
from ..schemas.tag import TagCreate, TagUpdate
from .cache_service import cache_service

class FolderService:
    async def create_folder(self, db: Session, user_id: str, data: FolderCreate) -> Folder:
        folder = Folder(
            user_id=user_id,
            name=data.name,
            description=data.description
        )
        
        db.add(folder)
        db.commit()
        db.refresh(folder)
        
        # Clear folder cache for user
        await cache_service.delete(f"folders:{user_id}")
        return folder

    async def get_user_folders(self, db: Session, user_id: str) -> List[Folder]:
        # Try cache first
        cached = await cache_service.get(f"folders:{user_id}")
        if cached:
            return [Folder(**f) for f in cached]

        folders = db.query(Folder).filter(Folder.user_id == user_id).all()
        
        # Cache the results
        await cache_service.set(f"folders:{user_id}", [f.__dict__ for f in folders])
        return folders

    async def update_folder(
        self, 
        db: Session, 
        folder_id: str, 
        user_id: str, 
        data: FolderUpdate
    ) -> Folder:
        folder = db.query(Folder).filter(
            Folder.id == folder_id,
            Folder.user_id == user_id
        ).first()
        
        if not folder:
            raise HTTPException(status_code=404, detail="Folder not found")

        for key, value in data.dict(exclude_unset=True).items():
            setattr(folder, key, value)

        db.commit()
        db.refresh(folder)
        
        # Clear folder cache
        await cache_service.delete(f"folders:{user_id}")
        return folder

folder_service = FolderService()

class TagService:
    async def create_tag(self, db: Session, user_id: str, data: TagCreate) -> Tag:
        tag = Tag(
            user_id=user_id,
            name=data.name,
            color=data.color
        )
        
        db.add(tag)
        db.commit()
        db.refresh(tag)
        
        # Clear tag cache
        await cache_service.delete(f"tags:{user_id}")
        return tag

    async def get_user_tags(self, db: Session, user_id: str) -> List[Tag]:
        # Try cache first
        cached = await cache_service.get(f"tags:{user_id}")
        if cached:
            return [Tag(**t) for t in cached]

        tags = db.query(Tag).filter(Tag.user_id == user_id).all()
        
        # Cache the results
        await cache_service.set(f"tags:{user_id}", [t.__dict__ for t in tags])
        return tags

tag_service = TagService()